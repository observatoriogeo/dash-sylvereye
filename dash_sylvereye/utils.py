# -*- coding: utf-8 -*-
# Author: Alberto Garcia-Robledo

import shapely.wkt
import networkx as nx
import json
import sys
from memoization import cached
from .defaults import DEFAULT_NODE_OPTIONS, DEFAULT_EDGE_OPTIONS, DEFAULT_MARKER_OPTIONS

def get_edge_middle_coords(edge):
    """
    Return the coordinates at the middle of a raod edge.
    args:
        - edge: the edge with the "coords" property.
    returns:
        - The coordinates [lan, lon] at the middle of the road edge.
    """
    if len(edge["coords"]) > 0:
        middle_index = int(len(edge["coords"])/2)
        return edge["coords"][middle_index]
    else:
        return None

def generate_markers_from_coords(coords, icon_id="custom_marker", icon_filen="", tooltips=[]):
    """
    Generate Sylvereye markers data from a set of coords.
    args:
        - coords: set of coords [[lat1, lon1], [lat2, lon2], ...].        
        - icon_filen: File name of the SVG icon for the markers (optional)
        - tooltips: List of tooltip texts for markers. Must habe the same length than coords.
    returns:
        - Sylvereye markers data.
    """

    if len(tooltips) == 0:
        tooltips = [""]*len(coords)

    markers = [
        {
            "icon_id": icon_id,
            "icon_image": open(icon_filen, "r+").read() if icon_filen != "" else "",
            "lat": latlon[0],
            "lon": latlon[1],
            "color": DEFAULT_MARKER_OPTIONS["color_default"],            
            "visible": True,
            "alpha": 1.0,
            "size": DEFAULT_MARKER_OPTIONS["size_default"],
            "size_scale_min": DEFAULT_MARKER_OPTIONS["size_default"],
            "size_scale_max": DEFAULT_MARKER_OPTIONS["size_default"],
            "data": {},
            "tooltip": tooltips[i]
        }
        for i, latlon in enumerate(coords)
    ]
    return markers


def load_from_osmnx_graph(g):
    """
    Load a Sylvereye road network from a NetworkX graph generated by OSMnx.
    args:
        - g: the NetworkX graph
    returns:
        - The Sylvereye nodes data list
        - The Sylvereye edges data list  
    """

    def get_coords_list(edge):
        if "geometry" in edge[2].keys():
            return [list(reversed(coords)) for coords in edge[2]["geometry"].coords]
        else:
            return [[float(g.nodes(data=True)[edge[0]]["y"]), float(g.nodes(data=True)[edge[0]]["x"])], [float(g.nodes(data=True)[edge[1]]["y"]), float(g.nodes(data=True)[edge[1]]["x"])]]

    # nodes data
    nodes_data = [
        {
            "lon": node[1]["x"],
            "lat": node[1]["y"],            
            "visible": True,
            "alpha": 1.0,
            "size": DEFAULT_NODE_OPTIONS["size_default"],
            "color": DEFAULT_NODE_OPTIONS["color_default"],
            "data": {
                "osmid": node[1]["osmid"] if "osmid" in node[1].keys() else None,
                "highway": node[1]["highway"] if "highway" in node[1].keys() else None,
                "x": node[1]["x"],
                "y": node[1]["y"]
            }
        }
        for node in g.nodes(data=True)
    ]

    # edges data
    edges_data = [
        {
            "coords": get_coords_list(edge),            
            "visible": True,
            "alpha": 1.0,
            "width": DEFAULT_EDGE_OPTIONS["width_default"],
            "color": DEFAULT_EDGE_OPTIONS["color_default"],
            "data": {
                "source_osmid": edge[0],
                "target_osmid": edge[1],
                "access": edge[2]["access"] if "access" in edge[2].keys() else None,
                "bridge": edge[2]["bridge"] if "bridge" in edge[2].keys() else None,
                "geometry": str(edge[2]["geometry"]) if "geometry" in edge[2].keys() else None,
                "highway": edge[2]["highway"] if "highway" in edge[2].keys() else None,
                "junction": edge[2]["junction"] if "junction" in edge[2].keys() else None,
                "lanes": edge[2]["lanes"] if "lanes" in edge[2].keys() else None,
                "length": edge[2]["length"] if "length" in edge[2].keys() else None,
                "maxspeed": edge[2]["maxspeed"] if "maxspeed" in edge[2].keys() else None,
                "name": edge[2]["name"] if "name" in edge[2].keys() else None,
                "oneway": edge[2]["oneway"] if "oneway" in edge[2].keys() else None,
                "osmid": edge[2]["osmid"] if "osmid" in edge[2].keys() else None,
                "ref": edge[2]["ref"] if "ref" in edge[2].keys() else None,
                "service": edge[2]["service"] if "service" in edge[2].keys() else None
            }
        }
        for edge in g.edges(data=True)
    ]

    return nodes_data, edges_data


def load_from_osmnx_graphml(filen):
    """
    Load a Sylvereye road network from a GraphML graph generated by OSMnx.
    args:
        - filen: file name of the GraphML file.
    returns:
        - The Sylvereye nodes data list
        - The Sylvereye edges data list
        - The NetworkX road network graph
    """

    def get_coords_list(edge):
        if "geometry" in edge[2].keys():
            return [list(reversed(coords)) for coords in shapely.wkt.loads(edge[2]["geometry"]).coords]
        else:
            return [[float(g.nodes(data=True)[edge[0]]["y"]), float(g.nodes(data=True)[edge[0]]["x"])], [float(g.nodes(data=True)[edge[1]]["y"]), float(g.nodes(data=True)[edge[1]]["x"])]]

    g = nx.read_graphml(filen)

    # nodes data
    nodes_data = [
        {
            "lon": float(node[1]["x"]),
            "lat": float(node[1]["y"]),            
            "visible": True,
            "alpha": 1.0,
            "size": DEFAULT_NODE_OPTIONS["size_default"],
            "color": DEFAULT_NODE_OPTIONS["color_default"],
            "data": {
                "osmid": json.loads(node[1]["osmid"]) if "osmid" in node[1].keys() else None,
                "highway": node[1]["highway"] if "highway" in node[1].keys() else None,
                "x": float(node[1]["x"]),
                "y": float(node[1]["y"])
            }
        }
        for node in g.nodes(data=True)
    ]

    # edges data
    edges_data = [
        {
            "coords": get_coords_list(edge),            
            "visible": True,
            "alpha": 1.0,
            "width": DEFAULT_EDGE_OPTIONS["width_default"],
            "color": DEFAULT_EDGE_OPTIONS["color_default"],
            "data": {
                "source_osmid": edge[0],
                "target_osmid": edge[1],
                "access": edge[2]["access"] if "access" in edge[2].keys() else None,
                "bridge": edge[2]["bridge"] if "bridge" in edge[2].keys() else None,
                "geometry": edge[2]["geometry"] if "geometry" in edge[2].keys() else None,
                "highway": edge[2]["highway"] if "highway" in edge[2].keys() else None,
                "id": edge[2]["id"] if "id" in edge[2].keys() else None,
                "junction": edge[2]["junction"] if "junction" in edge[2].keys() else None,
                "lanes": edge[2]["lanes"] if "lanes" in edge[2].keys() else None,
                "length": edge[2]["length"] if "length" in edge[2].keys() else None,
                "maxspeed": edge[2]["maxspeed"] if "maxspeed" in edge[2].keys() else None,
                "name": edge[2]["name"] if "name" in edge[2].keys() else None,
                "oneway": edge[2]["oneway"] if "oneway" in edge[2].keys() else None,
                "osmid": json.loads(edge[2]["osmid"]) if "osmid" in edge[2].keys() else None,
                "ref": edge[2]["ref"] if "ref" in edge[2].keys() else None,
                "service": edge[2]["service"] if "service" in edge[2].keys() else None
            }
        }
        for edge in g.edges(data=True)
    ]

    return nodes_data, edges_data, g


def load_from_sumo_network(filen, sumolib_path="/usr/share/sumo/tools"):
    """
    Load a Sylvereye road network from a SUMO road network file.
    args:
        - filen: file name of the SUMO road network file.
        - sumolib_path: path of the SUMO sumolib library, usually the "tools" folder of the SUMO path.
    returns:
        - The Sylvereye nodes data list.
        - The Sylvereye edges data list.
        - The SUMO road network graph.
    """ 

    sys.path.append(sumolib_path)
    import sumolib
    
    import time
    #print("loading roadnet ...")
    start = time.time()
    g = sumolib.net.readNet(filen)
    end = time.time()
    #print(end - start)

    @cached
    def covert_to_lonlat(coordinates):
        return g.convertXY2LonLat(*coordinates) # convertXY2LonLat uses pyproj and seems to be the CPU-bounded bottleneck
    
    #print("loading node data...")
    start = time.time()    
    # nodes data
    nodes_data = [
        {
            # this needs pyproj
            "lon": covert_to_lonlat(node.getCoord())[0], # cached
            # this needs pyproj
            "lat": covert_to_lonlat(node.getCoord())[1], # cached            
            "visible": True,
            "alpha": 1.0,
            "size": DEFAULT_NODE_OPTIONS["size_default"],
            "color": DEFAULT_NODE_OPTIONS["color_default"],
            "data": {
                "id": node.getID(),
                "type": node.getType(),
                "lat": covert_to_lonlat(node.getCoord())[1], # cached
                "lon": covert_to_lonlat(node.getCoord())[0], # cached
            }
        }
        for node in g.getNodes()
    ]
    end = time.time()
    #print(end - start)
    
    #print("loading edges data...")
    start = time.time()    
    # edges data
    edges_data = [
        {
            # this needs pyproj
            "coords": [list(reversed(covert_to_lonlat(coords))) for coords in edge.getShape()], # cached            
            "visible": True,
            "alpha": 1.0,
            "width": DEFAULT_EDGE_OPTIONS["width_default"],
            "color": DEFAULT_EDGE_OPTIONS["color_default"],
            "data": {
                "id": edge.getID(),
                "from_node_id": edge.getFromNode().getID(),
                "to_node_id": edge.getToNode().getID(),
                "length": edge.getLength(),
                "name": edge.getName(),
                "priority": edge.getPriority(),
                "is_special": edge.isSpecial(),
                "speed": edge.getSpeed(),
                "function": edge.getFunction(),
                "lane_number": edge.getLaneNumber(),
                "lanes": [{
                    "id": lane.getID(),
                    "length": lane.getLength(),
                    "speed": lane.getSpeed(),
                    "width": lane.getWidth(),
                    "coords": [list(reversed(covert_to_lonlat(coords))) for coords in edge.getShape()] # cached
                } for lane in edge.getLanes()]
            }
        }
        for edge in g.getEdges()
    ]
    end = time.time()
    #print(end - start)    

    return nodes_data, edges_data, g
